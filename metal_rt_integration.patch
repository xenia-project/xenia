--- a/src/xenia/gpu/metal/metal_command_processor.mm
+++ b/src/xenia/gpu/metal/metal_command_processor.mm
@@ -1217,6 +1217,29 @@ bool MetalCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,
   XELOGI("Metal IssueDraw: Using real Xbox 360 shaders - vertex: {:016x}, pixel: {:016x}",
          vertex_shader->ucode_data_hash(), pixel_shader->ucode_data_hash());
   
+  // REFACTOR: Use base RenderTargetCache infrastructure
+  // Calculate normalized color mask based on pixel shader outputs
+  uint32_t normalized_color_mask = pixel_shader ? 
+      draw_util::GetNormalizedColorMask(regs, pixel_shader->writes_color_targets()) : 0;
+  
+  // Get normalized depth control
+  reg::RB_DEPTHCONTROL normalized_depth_control = 
+      draw_util::GetNormalizedDepthControl(regs);
+  
+  // Determine if rasterization is done (not a memexport-only draw)
+  bool is_rasterization_done = true;  // For now, assume rasterization is always done
+  
+  // Call base RenderTargetCache::Update() - this handles:
+  // - EDRAM snapshot interpretation when registers are zero
+  // - Render target creation from EDRAM contents
+  // - Complex render target resolution
+  if (!render_target_cache_->Update(is_rasterization_done,
+                                    normalized_depth_control,
+                                    normalized_color_mask,
+                                    *vertex_shader)) {
+    XELOGE("Metal IssueDraw: RenderTargetCache::Update failed");
+    return false;
+  }
+  
   // IMPORTANT: Update render targets BEFORE creating pipeline so we get the correct formats
   // Parse RB_SURFACE_INFO and RB_COLOR_INFO registers to determine active render targets
   uint32_t rb_surface_info = register_file_->values[XE_GPU_REG_RB_SURFACE_INFO];
@@ -1235,43 +1258,9 @@ bool MetalCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,
   XELOGI("Metal IssueDraw: RB_DEPTH_INFO = 0x{:08X}", rb_depth_info);
   
   // Process all color render targets - Xbox 360 allows multiple RTs at same address
-  // This is used for effects like deferred lighting (4D5307E6) where different
-  // shader outputs write to the same EDRAM location
-  uint32_t color_targets[4] = {0};
-  uint32_t rt_count = 0;
-  uint32_t duplicate_rt_mask = 0;
-  
-  // First pass: collect all valid color targets
-  for (uint32_t i = 0; i < 4; ++i) {
-    // Check if render target is enabled (base address != 0)
-    uint32_t base_address = rb_color_info[i] & 0xFFFFF000;
-    if (base_address != 0) {
-      color_targets[rt_count++] = rb_color_info[i];
-    }
-  }
-  
-  // The render target cache will automatically create a dummy color target
-  // when rt_count == 0, so we don't need to create a fake configuration here
-  
-  // Second pass: detect duplicates for special handling
-  for (uint32_t i = 0; i < rt_count; ++i) {
-    uint32_t addr_i = color_targets[i] & 0xFFFFF000;
-    for (uint32_t j = i + 1; j < rt_count; ++j) {
-      uint32_t addr_j = color_targets[j] & 0xFFFFF000;
-      if (addr_i == addr_j) {
-        duplicate_rt_mask |= (1u << i) | (1u << j);
-      }
-    }
-  }
-  
-  if (duplicate_rt_mask) {
-    XELOGI("Metal IssueDraw: Detected duplicate render targets at same EDRAM address (mask 0x{:X})", 
-           duplicate_rt_mask);
-  }
-  
-  // The depth target setup happens independently
-  uint32_t depth_target = rb_depth_info;
-  
-  // Set up render targets - this configures our render pass
-  render_target_cache_->SetRenderTargets(rt_count, color_targets, depth_target);
+  // NOTE: The base RenderTargetCache::Update() already handled render target setup
+  // based on registers and EDRAM snapshot. We don't need to manually parse
+  // RB_COLOR_INFO anymore - the base class does this correctly.
   
   // Phase B Step 3: Get or create the pipeline state

--- a/src/xenia/gpu/metal/metal_command_processor.h
+++ b/src/xenia/gpu/metal/metal_command_processor.h
@@ -18,6 +18,7 @@
 #include "xenia/gpu/command_processor.h"
 #include "xenia/gpu/metal/metal_buffer_cache.h"
 #include "xenia/gpu/metal/metal_pipeline_cache.h"
+#include "xenia/gpu/draw_util.h"
 #include "xenia/gpu/metal/metal_primitive_processor.h"
 #include "xenia/gpu/metal/metal_render_target_cache.h"
 #include "xenia/gpu/metal/metal_shader.h"