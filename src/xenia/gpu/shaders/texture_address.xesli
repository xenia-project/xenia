/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2022 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#ifndef XENIA_GPU_SHADERS_TEXTURE_ADDRESS_XESLI_
#define XENIA_GPU_SHADERS_TEXTURE_ADDRESS_XESLI_

#include "../../ui/shaders/xesl.xesli"

#define XENOS_TEXTURE_MACRO_TILE_WIDTH_LOG2 5
#define XENOS_TEXTURE_MACRO_TILE_HEIGHT_2D_LOG2 5
#define XENOS_TEXTURE_MACRO_TILE_HEIGHT_3D_LOG2 4
#define XENOS_TEXTURE_MACRO_TILE_DEPTH_LOG2 2

int XenosTextureTiledAddressCombine(const int outer_inner_bytes, const int bank,
                                    const int pipe, const int y_lsb) {
  return (y_lsb << 4) | (pipe << 6) | (bank << 11) | (outer_inner_bytes & 0xF) |
         (((outer_inner_bytes >> 4) & 0x1) << 5) |
         (((outer_inner_bytes >> 5) & 0x7) << 8) |
         (outer_inner_bytes >> 8 << 12);
}

int XenosTextureTiledAddress2D(const int2_xe p, const uint pitch_macro_tiles,
                               const uint bytes_per_element_log2) {
  const int outer_elements =
      ((p.y >> XENOS_TEXTURE_MACRO_TILE_HEIGHT_2D_LOG2) *
           int(pitch_macro_tiles) +
       (p.x >> XENOS_TEXTURE_MACRO_TILE_WIDTH_LOG2))
      << 6;
  const int inner_elements = (((p.y >> 1) & 0x7) << 3) | (p.x & 0x7);
  const int outer_inner_bytes =
      (outer_elements | inner_elements) << bytes_per_element_log2;
  const int bank = (p.y >> 4) & 0x1;
  const int pipe = ((p.x >> 3) & 0x3) ^ (((p.y >> 3) & 0x1) << 1);
  return XenosTextureTiledAddressCombine(outer_inner_bytes, bank, pipe,
                                         p.y & 1);
}

int XenosTextureTiledAddress3D(const int3_xe p, const uint pitch_macro_tiles,
                               const uint height_macro_tiles,
                               const uint bytes_per_element_log2) {
  const int outer_elements =
      ((((p.z >> XENOS_TEXTURE_MACRO_TILE_DEPTH_LOG2) *
             int(height_macro_tiles) +
         (p.y >> XENOS_TEXTURE_MACRO_TILE_HEIGHT_3D_LOG2)) *
        int(pitch_macro_tiles)) +
       (p.x >> XENOS_TEXTURE_MACRO_TILE_WIDTH_LOG2))
      << 7;
  const int inner_elements =
      ((p.z & 0x3) << 5) | (((p.y >> 1) & 0x3) << 3) | (p.x & 0x7);
  const int outer_inner_bytes =
      (outer_elements | inner_elements) << bytes_per_element_log2;
  const int bank = ((p.y >> 3) ^ (p.z >> 2)) & 0x1;
  const int pipe = ((p.x >> 3) & 0x3) ^ (bank << 1);
  return XenosTextureTiledAddressCombine(outer_inner_bytes, bank, pipe,
                                         p.y & 1);
}

// Log2 of the number of blocks always laid out consecutively in memory along
// the horizontal axis.
uint XeTextureTiledConsecutiveBlocksLog2(uint bpb_log2) {
  // 1bpb and 2bpb - 8.
  // 4bpb - 4.
  // 8bpb - 2.
  // 16bpb - 1.
  return min(4u - bpb_log2, 3u);
}

// Odd sequences of consecutive blocks along the horizontal axis are placed at a
// fixed offset in memory from the preceding even ones. Returns the distance
// between the beginnings of the even and its corresponding odd sequences.
uint XeTextureTiledOddConsecutiveBlocksOffset(uint bpb_log2) {
  return bpb_log2 >= 2u ? 32u : 64u;
}

// For shaders to be able to copy multiple horizontally adjacent pixels in the
// same way regardless of the resolution scale chosen, scaling is done at Nx1
// granularity where N matches the number of pixels that are consecutive with
// guest tiling, rather than within individual guest pixels:
// - 1bpp - 8x1 host pixels (can copy via R32G32_UINT)
// - 2bpp - 8x1 host pixels (can copy via R32G32B32A32_UINT)
// - 4bpp - 4x1 host pixels
// - 8bpp - 2x1 host pixels
// - 16bpp - 1x1 host pixels
// For better access locality, because compute shaders in Xenia usually have 2D
// thread groups, host Nx1 sub-units are scaled within guest Nx1 units in a
// column-major way.
// So, for example, in a 2bpp texture with 2x2 resolution scale, 16 guest bytes,
// or 64 host bytes, contain:
// - 16 host bytes - 8x1 top-left portion
// - 16 host bytes - 8x1 bottom-left portion
// - 16 host bytes - 8x1 top-right portion
// - 16 host bytes - 8x1 bottom-right portion
// This function is used only for non-negative positions within a texture, so
// for simplicity, especially of the division involved, assuming everything is
// unsigned.
uint XeTextureScaledTiledOffset(bool is_3d, uint3_xe p, uint pitch_aligned_shr5,
                                uint height_aligned_shr4, uint bpb_log2,
                                uint2_xe scale) {
  uint unit_width_log2 = XeTextureTiledConsecutiveBlocksLog2(bpb_log2);
  // Global host X coordinate in host Nx1 sub-units.
  uint x_subunits = p.x >> unit_width_log2;
  // Global guest XY coordinate in guest Nx1 units.
  uint2_xe xy_unit_guest = uint2_xe(x_subunits, p.y) / scale;
  // Global guest XYZ coordinate of the beginning of the Nx1 unit.
  uint3_xe unit_guest_origin =
      uint3_xe(xy_unit_guest.x << unit_width_log2, xy_unit_guest.y, p.z);
  // Global guest linear address of the beginning of Nx1 unit in bytes.
  uint unit_guest_address;
  dont_flatten_xe if (is_3d) {
    unit_guest_address = uint(XenosTextureTiledAddress3D(
        int3_xe(unit_guest_origin), pitch_aligned_shr5, height_aligned_shr4,
        bpb_log2));
  } else {
    unit_guest_address = uint(XenosTextureTiledAddress2D(
        int2_xe(unit_guest_origin.xy), pitch_aligned_shr5, bpb_log2));
  }
  // Unit-local host XY index of the host Nx1 sub-unit.
  // Also see XeTextureScaledRightSubUnitOffsetInConsecutivePair for common
  // subexpression elimination information as this remainder calculation is done
  // there too.
  uint2_xe unit_subunit = uint2_xe(x_subunits, p.y) - xy_unit_guest * scale;
  // Combine:
  // - Guest global unit address.
  // - Host unit-local sub-unit index.
  // - Host pixel within a sub-unit (if the offset is requested at a smaller
  //   granularity than a whole sub-unit).
  return unit_guest_address * (scale.x * scale.y) +
         ((((unit_subunit.x * scale.y + unit_subunit.y) << unit_width_log2) +
           (p.x & ((1u << unit_width_log2) - 1u)))
          << bpb_log2);
}

// Offset of the beginning of next host sub-unit along the horizontal axis
// within a pair of guest units.
// x must be a multiple of 1 << (XeTextureTiledConsecutiveBlocksLog2 + 1) - to
// go from one pair of consecutive blocks to another, full tiled offset
// recalculation is required.
uint XeTextureScaledRightSubUnitOffsetInConsecutivePair(uint x, uint bpb_log2,
                                                        uint2_xe scale) {
  uint right_sub_unit_offset_columns;
  uint tiled_consecutive_offset =
      XeTextureTiledOddConsecutiveBlocksOffset(bpb_log2);
  dont_flatten_xe if (scale.x > 1u) {
    uint subunit_width_log2 = XeTextureTiledConsecutiveBlocksLog2(bpb_log2);
    uint subunit_size_log2 = subunit_width_log2 + bpb_log2;
    // While % can be used here to take the modulo, for better common
    // subexpression elimination between this function and
    // XeTextureScaledTiledOffset when both are used, taking the remainder the
    // same way.
    uint x_subunits = x >> subunit_width_log2;
    uint unit_subunit_x = x_subunits - (x_subunits / scale.x) * scale.x;
    if (unit_subunit_x + 1u == scale.x) {
      // The next host sub-unit is in the other, odd guest unit.
      right_sub_unit_offset_columns = tiled_consecutive_offset * scale.x -
                                      (unit_subunit_x << subunit_size_log2);
    } else {
      // The next host sub-unit is in the same guest unit.
      right_sub_unit_offset_columns = 1u << subunit_size_log2;
    }
  } else {
    right_sub_unit_offset_columns = tiled_consecutive_offset;
  }
  // The layout of sub-units within one unit is column-major.
  return right_sub_unit_offset_columns * scale.y;
}

int XeTextureGuestLinearOffset(int3_xe p, uint pitch, uint height_aligned,
                               uint bpb) {
  return p.x * int(bpb) + (p.z * int(height_aligned) + p.y) * int(pitch);
}

int XeTextureHostLinearOffset(int3_xe p, uint pitch, uint height, uint bpb) {
  return p.x * int(bpb) + (p.z * int(height) + p.y) * int(pitch);
}

#endif  // XENIA_GPU_SHADERS_TEXTURE_ADDRESS_XESLI_
