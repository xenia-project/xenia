#!/usr/bin/env python3

# Copyright 2015 Ben Vanik. All Rights Reserved.

"""Premake trampoline script.
"""

__author__ = 'ben.vanik@gmail.com (Ben Vanik)'


import json
import os
import shutil
import subprocess
import sys
import re


self_path = os.path.dirname(os.path.abspath(__file__))
root_path = os.path.join(self_path, '..', '..')
premake_submodule_path = os.path.join(root_path, 'third_party', 'premake-core')
premake_path = premake_submodule_path


def setup_premake_path_override():
  global premake_path
  premake_path = premake_submodule_path
  if sys.platform == 'linux':
    # On Android, the repository may be cloned to the external storage, which
    # doesn't support executables in it.
    # In this case, premake-core needs to be checked out in the internal
    # storage, which supports executables, with all the permissions as set in
    # its repository.
    # On Termux, the home directory is in the internal storage - use it for
    # executing.
    # If xenia-build doesn't have execute permissions, Xenia is in the external
    # storage now.
    try:
      popen = subprocess.Popen(
          ['uname', '-o'], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
          universal_newlines=True)
      if popen.communicate()[0] == 'Android\n':
        xb_file = os.path.join(root_path, 'xenia-build')
        if (os.path.isfile(xb_file) and not os.access(xb_file, os.X_OK) and
            'HOME' in os.environ):
          premake_path = os.path.join(
              os.environ['HOME'], '.xenia-build', 'premake-core')
    except Exception:
      pass

setup_premake_path_override()


def main():
  # First try the freshly-built premake.
  premake5_bin = os.path.join(premake_path, 'bin', 'release', 'premake5')
  if not has_bin(premake5_bin):
    # No fresh build, so fallback to checked in copy (which we may not have).
    premake5_bin = os.path.join(self_path, 'bin', 'premake5')
  if not has_bin(premake5_bin):
    # Still no valid binary, so build it.
    print('premake5 executable not found, attempting build...')
    build_premake()
    premake5_bin = os.path.join(premake_path, 'bin', 'release', 'premake5')
  if not has_bin(premake5_bin):
    # Nope, boned.
    print('ERROR: cannot build premake5 executable.')
    sys.exit(1)

  # Ensure the submodule has been checked out.
  if not os.path.exists(os.path.join(premake_path, 'scripts', 'package.lua')):
    print('third_party/premake-core was not present; run xb setup...')
    sys.exit(1)
    return

  if sys.platform == 'win32':
    # Append the executable extension on windows.
    premake5_bin = premake5_bin + '.exe'

  return_code = shell_call([
      premake5_bin,
      '--scripts=%s' % (premake_path),
      ] + sys.argv[1:],
      throw_on_error=False)

  sys.exit(return_code)


def build_premake():
  """Builds premake from source.
  """
  # Ensure that on Android, premake-core is in the internal storage.
  clone_premake_to_internal_storage()
  cwd = os.getcwd()
  try:
    os.chdir(premake_path)
    if sys.platform == 'darwin':
      # Detect the host architecture for macOS
      import platform
      machine = platform.machine().lower()
      if machine in ['arm64', 'aarch64']:
        bootstrap_platform = 'ARM64'
      else:
        bootstrap_platform = 'x86_64'
      
      subprocess.call([
          'make',
          '-f', 'Bootstrap.mak',
          'PLATFORM=' + bootstrap_platform,
          'osx',
          ], shell=False)
    elif sys.platform == 'win32':
      # Grab Visual Studio version and execute shell to set up environment.
      vs_version = import_vs_environment()
      if vs_version is None:
        print('ERROR: Visual Studio not found!')
        sys.exit(1)
        return

      # NOTE: On ARM64 Windows, the Bootstrap.mak doesn't support the arm64
      # architecture flag for the bootstrap premake. We use PLATFORM=x86 which
      # builds a bootstrap premake that can generate the proper ARM64 projects.
      # The final premake5.exe will be built for the correct architecture.
      # We also need to use a newer VS version than the default vs2012
      vs_year = 'vs2022'
      if 'VSVERSION' in os.environ:
        vs_ver = os.environ['VSVERSION']
        if vs_ver == '2019':
          vs_year = 'vs2019'
        elif vs_ver == '2017':
          vs_year = 'vs2017'
      
      # Detect the host architecture for the bootstrap
      import platform
      machine = platform.machine().lower()
      if machine in ['arm64', 'aarch64']:
        bootstrap_platform = 'ARM64'  # Use uppercase ARM64 as shown in help
      else:
        bootstrap_platform = 'x86'
      
      # Use windows-msbuild target instead of windows to avoid devenv issues
      subprocess.call([
          'nmake',
          '-f', 'Bootstrap.mak',
          'PLATFORM=' + bootstrap_platform,
          'MSDEV=' + vs_year,  # Use current VS version instead of vs2012
          'windows-msbuild',  # Use msbuild directly instead of devenv
          ], shell=False)
    else:
      # Detect the host architecture for Linux builds
      import platform
      machine = platform.machine().lower()
      if machine in ['arm64', 'aarch64']:
        bootstrap_platform = 'ARM64'
        arch_flag = '--arch=ARM64'
      elif machine in ['x86_64', 'amd64']:
        bootstrap_platform = 'x86_64'
        arch_flag = '--arch=x86_64'
      else:
        # Default to x86_64 for unknown architectures
        bootstrap_platform = 'x86_64'
        arch_flag = '--arch=x86_64'
      
      # Pass architecture via PREMAKE_OPTS environment variable
      # which gets used by Bootstrap.mak in the premake_bootstrap command
      env = os.environ.copy()
      env['PREMAKE_OPTS'] = arch_flag
      env['PLATFORM'] = bootstrap_platform
      # Work around implicit function declaration errors in modern compilers
      # by allowing implicit function declarations for the premake build
      env['CFLAGS'] = '-Wno-error=implicit-function-declaration'
      if 'CFLAGS' in os.environ:
        env['CFLAGS'] = os.environ['CFLAGS'] + ' -Wno-error=implicit-function-declaration'
      
      subprocess.call([
          'make',
          '-f', 'Bootstrap.mak',
          'linux',
          ], shell=False, env=env)
  finally:
    os.chdir(cwd)
  pass


def clone_premake_to_internal_storage():
  """Clones premake to the Android internal storage so it can be executed.
  """
  # premake_path is initialized to a value different than premake_submodule_path
  # if running from the Android external storage, and may not exist yet.
  if premake_path == premake_submodule_path:
    return

  # Ensure the submodule has been checked out.
  if not os.path.exists(
      os.path.join(premake_submodule_path, 'scripts', 'package.lua')):
    print('third_party/premake-core was not present; run xb setup...')
    sys.exit(1)
    return

  # Create or refresh premake-core in the internal storage.
  print('Cloning premake5 to the internal storage...')
  shutil.rmtree(premake_path, ignore_errors=True)
  os.makedirs(premake_path)
  shell_call([
      'git',
      'clone',
      '--recurse-submodules',
      premake_submodule_path,
      premake_path,
      ])


def has_bin(bin):
  """Checks whether the given binary is present and executable on this platform.
  """
  # Check if the binary path was provided directly (not just a name)
  if os.path.isfile(bin):
    exe_file = bin
    # Try to execute it to ensure it's compatible with this platform
    try:
      subprocess.run([exe_file, '--version'], 
                     stdout=subprocess.DEVNULL, 
                     stderr=subprocess.DEVNULL,
                     timeout=1)
      return True
    except (subprocess.SubprocessError, OSError, FileNotFoundError):
      return False
  
  # Original PATH search logic
  for path in os.environ["PATH"].split(os.pathsep):
    if sys.platform == 'win32':
      exe_file = os.path.join(path, bin + '.exe')
      if os.path.isfile(exe_file) and os.access(exe_file, os.X_OK):
        return True
    else:
      path = path.strip('"')
      exe_file = os.path.join(path, bin)
      if os.path.isfile(exe_file) and os.access(exe_file, os.X_OK):
        return True
  return None


def shell_call(command, throw_on_error=True, stdout_path=None, stderr_path=None, shell=False):
  """Executes a shell command.

  Args:
    command: Command to execute, as a list of parameters.
    throw_on_error: Whether to throw an error or return the status code.
    stdout_path: File path to write stdout output to.
    stderr_path: File path to write stderr output to.

  Returns:
    If throw_on_error is False the status code of the call will be returned.
  """
  stdout_file = None
  if stdout_path:
    stdout_file = open(stdout_path, 'w')
  stderr_file = None
  if stderr_path:
    stderr_file = open(stderr_path, 'w')
  result = 0
  try:
    if throw_on_error:
      result = 1
      subprocess.check_call(command, shell=shell, stdout=stdout_file, stderr=stderr_file)
      result = 0
    else:
      result = subprocess.call(command, shell=shell, stdout=stdout_file, stderr=stderr_file)
  finally:
    if stdout_file:
      stdout_file.close()
    if stderr_file:
      stderr_file.close()
  return result


def import_vs_environment():
  """Finds the installed Visual Studio version and imports
  interesting environment variables into os.environ.

  Returns:
  A version such as 2015 or None if no installation is found.
  """
  version = 0
  install_path = None
  env_tool_args = None

  vswhere = subprocess.check_output('tools/vswhere/vswhere.exe -version "[15,)" -latest -format json -utf8', shell=False, universal_newlines=True, encoding="utf-8")
  if vswhere:
    vswhere = json.loads(vswhere)
  if vswhere and len(vswhere) > 0:
    version = int(vswhere[0].get("catalog", {}).get("productLineVersion", 2017))
    install_path = vswhere[0].get("installationPath", None)

  if version < 2017:
    if 'VS140COMNTOOLS' in os.environ:
      version = 2015
      vcvars_path = os.environ['VS140COMNTOOLS']
      vcvars_path = os.path.join(vcvars_path, '..\\..\\vc\\vcvarsall.bat')
      
      # Detect the host architecture
      import platform
      machine = platform.machine().lower()
      if machine in ['arm64', 'aarch64']:
        arch = 'arm64'
      else:
        arch = 'x64'
      
      env_tool_args = [vcvars_path, arch, '&&', 'set']
  else:
    # Detect the host architecture
    import platform
    machine = platform.machine().lower()
    if machine in ['arm64', 'aarch64']:
      arch = 'arm64'
      host_arch = 'arm64'
    else:
      arch = 'amd64'
      host_arch = 'amd64'
    
    vsdevcmd_path = os.path.join(install_path, 'Common7\\Tools\\VsDevCmd.bat')
    env_tool_args = [vsdevcmd_path, '-arch=' + arch, '-host_arch=' + host_arch, '&&', 'set']

  if version == 0:
    return None

  import_subprocess_environment(env_tool_args)
  os.environ['VSVERSION'] = str(version)
  return version


def import_subprocess_environment(args):
  popen = subprocess.Popen(
      args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
  variables, _ = popen.communicate()
  envvars_to_save = (
      'devenvdir',
      'include',
      'lib',
      'libpath',
      'path',
      'pathext',
      'systemroot',
      'temp',
      'tmp',
      'windowssdkdir',
      )
  for line in variables.splitlines():
    for envvar in envvars_to_save:
      if re.match(envvar + '=', line.lower()):
        var, setting = line.split('=', 1)
        if envvar == 'path':
          setting = os.path.dirname(sys.executable) + os.pathsep + setting
        os.environ[var.upper()] = setting
        break

if __name__ == '__main__':
  main()
